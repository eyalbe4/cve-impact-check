package commands

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/hashicorp/go-uuid"
	"github.com/jfrog/jfrog-cli-core/v2/plugins/components"
	"github.com/jfrog/jfrog-cli-core/v2/utils/config"
	"github.com/jfrog/jfrog-cli-core/v2/xray/commands"
	artUtils "github.com/jfrog/jfrog-client-go/artifactory/services/utils"
	clientutils "github.com/jfrog/jfrog-client-go/utils"
	"github.com/jfrog/jfrog-client-go/utils/errorutils"
	"github.com/jfrog/jfrog-client-go/utils/io/httputils"
	"github.com/jfrog/jfrog-client-go/utils/log"
	"github.com/jfrog/jfrog-client-go/xray"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"
)

type impactedComponent struct {
	Name        string `json:"name"`
	PackageType string `json:"package_type"`
	Version     string `json:"version"`
}

type impactedArtifact struct {
	Summary   string `json:"summary"`
	Component string `json:"vulnerable_component"`
	Artifact  string `json:"impacted_artifact"`
	Path      string `json:"path"`
}

func GetCheckCommand() components.Command {
	return components.Command{
		Name:        "check",
		Description: "Checks if a CVE/XRAY ID has impact on a system",
		Aliases:     []string{"c"},
		Arguments:   getCheckArguments(),
		Flags:       getCheckFlags(),
		EnvVars:     getCheckEnvVar(),
		Action: func(ctx *components.Context) error {
			return checkCmd(ctx)
		},
	}
}

func getCheckArguments() []components.Argument {
	return []components.Argument{
		{
			Name:        "issue_id",
			Description: "The CVE or XRAY ID of the issue",
		},
	}
}

func getCheckFlags() []components.Flag {
	return []components.Flag{
		components.BoolFlag{
			Name:         "export-impacted-artifacts",
			Description:  "Generate a report of the impacted artifacts",
			DefaultValue: false,
		},
		components.StringFlag{
			Name:         "repositories",
			Description:  "Comma separated list of repositories to check in",
			DefaultValue: "",
		},
		components.StringFlag{
			Name:         "output",
			Description:  "The destination output file",
			DefaultValue: "out.json",
		},
		components.StringFlag{
			Name:         "server-id",
			Description:  "The Server to connect to",
			DefaultValue: "",
		},
	}
}

func getCheckEnvVar() []components.EnvVar {
	return []components.EnvVar{}
}

type checkConfiguration struct {
	issueId         string
	exportArtifacts bool
	repositories    []string
	outputFile      string
	serverId        string
}

func checkCmd(ctx *components.Context) error {
	if len(ctx.Arguments) != 1 {
		return errors.New("Wrong number of arguments. Expected: 1, " + "Received: " + strconv.Itoa(len(ctx.Arguments)))
	}
	var conf = new(checkConfiguration)
	conf.issueId = ctx.Arguments[0]
	conf.exportArtifacts = ctx.GetBoolFlagValue("export-impacted-artifacts")

	reposStr := ctx.GetStringFlagValue("repositories")
	if reposStr == "" {
		conf.repositories = nil
	} else {
		conf.repositories = strings.Split(reposStr, ",")
	}

	if conf.exportArtifacts && conf.repositories == nil {
		//goland:noinspection GoErrorStringFormat
		return errors.New("When selecting to export the impacted artifacts, the repository selection is required")
	}

	conf.outputFile = ctx.GetStringFlagValue("output")
	conf.serverId = ctx.GetStringFlagValue("server-id")

	return doCheck(conf)
}

func doCheck(pluginConfig *checkConfiguration) error {
	serverConf, err := config.GetSpecificConfig(pluginConfig.serverId, true, false)

	if err != nil {
		return err
	}

	if serverConf.XrayUrl == "" {
		return errors.New("xray service is not configured")
	}

	xrayServiceMgr, err := commands.CreateXrayServiceManager(serverConf)
	if err != nil {
		return err
	}

	err = checkConnection(xrayServiceMgr)
	if err != nil {
		return err
	}

	if strings.HasPrefix(pluginConfig.issueId, "XRAY-") {
		cve, issueDetails, err := getIssueDetails(xrayServiceMgr, serverConf, pluginConfig.issueId)
		if err != nil {
			return err
		}
		printIssueDetails(cve, issueDetails)
		pluginConfig.issueId = cve
	} else if !strings.HasPrefix(pluginConfig.issueId, "CVE-") {
		return errors.New("incorrect ID format. Please use only XRAY-XXX or CVE-XXX formats")
	}

	impactedComponents, err := getImpactedComponents(xrayServiceMgr, serverConf, pluginConfig.issueId)
	if err != nil {
		return err
	}

	if len(impactedComponents) == 0 {
		log.Info("No impacted components found in the system")
		return nil
	}

	printImpactedComponents(impactedComponents)

	if pluginConfig.exportArtifacts {
		err = generateImpactedArtifactsReport(xrayServiceMgr, serverConf, pluginConfig)
		if err != nil {
			return err
		}
	}

	return nil
}

func generateImpactedArtifactsReport(xrayServiceMgr *xray.XrayServicesManager, serverConf *config.ServerDetails, pluginConfig *checkConfiguration) error {
	reportId, err := triggerNewReportGeneration(xrayServiceMgr, serverConf, pluginConfig)

	if err != nil {
		return err
	}

	defer func() {
		err = deleteReport(xrayServiceMgr, serverConf, reportId)
		if err != nil {
			log.Error("Was unable to remove report due to: " + err.Error())
			log.Error("You will need to manually remove the report from Xray UI")
		}
	}()

	err = waitForReportGeneration(xrayServiceMgr, serverConf, reportId)

	if err != nil {
		return err
	}

	err = exportReportToOutputFile(xrayServiceMgr, serverConf, pluginConfig, reportId)
	if err != nil {
		return err
	}

	return nil
}

func deleteReport(xrayServiceMgr *xray.XrayServicesManager, serverConf *config.ServerDetails, reportId int) error {
	log.Info("Deleting report...")
	url := clientutils.AddTrailingSlashIfNeeded(serverConf.XrayUrl) + "api/v1/reports/" + strconv.Itoa(reportId)
	httpClientsDetails := httputils.HttpClientDetails{
		User:     serverConf.GetUser(),
		Password: serverConf.GetPassword(),
	}

	resp, _, err := xrayServiceMgr.Client().SendDelete(url, nil, &httpClientsDetails)

	if err = errorutils.CheckResponseStatus(resp, http.StatusOK); err != nil {
		return err
	}

	return nil
}

func exportReportToOutputFile(xrayServiceMgr *xray.XrayServicesManager, serverConf *config.ServerDetails, pluginConfig *checkConfiguration, reportId int) error {
	log.Info("Downloading report data...")
	url := clientutils.AddTrailingSlashIfNeeded(serverConf.XrayUrl) + "api/v1/reports/vulnerabilities/" + strconv.Itoa(reportId)

	url = url + "?direction=asc&page_num=1&num_of_rows=10000&order_by=path"

	httpClientsDetails := httputils.HttpClientDetails{
		User:     serverConf.GetUser(),
		Password: serverConf.GetPassword(),
	}

	resp, body, err := xrayServiceMgr.Client().SendPost(url, nil, &httpClientsDetails)
	if err != nil {
		return err
	}

	if err = errorutils.CheckResponseStatus(resp, http.StatusOK); err != nil {
		return err
	}

	response := struct {
		Rows []impactedArtifact `json:"rows,omitempty"`
	}{}

	err = json.Unmarshal(body, &response)

	if err != nil {
		return errors.New("failed unmarshalling response: " + err.Error())
	}

	if len(response.Rows) == 0 {
		log.Info("No impacted artifacts detected")
	} else {
		content, err := json.Marshal(response.Rows)
		if err != nil {
			return err
		}

		outputFile, err := os.Create(pluginConfig.outputFile)
		defer func() {
			_ = outputFile.Close()
		}()
		_, err = outputFile.Write(content)
		if err != nil {
			return err
		}
	}
	return nil
}

func waitForReportGeneration(xrayServiceMgr *xray.XrayServicesManager, serverConf *config.ServerDetails, reportId int) error {
	log.Info("Waiting for report to finish execution...")
	url := clientutils.AddTrailingSlashIfNeeded(serverConf.XrayUrl) + "api/v1/reports/" + strconv.Itoa(reportId)
	httpClientsDetails := httputils.HttpClientDetails{
		User:     serverConf.GetUser(),
		Password: serverConf.GetPassword(),
	}

	for true {
		resp, body, _, err := xrayServiceMgr.Client().SendGet(url, true, &httpClientsDetails)
		if err != nil {
			return err
		}

		if err = errorutils.CheckResponseStatus(resp, http.StatusOK); err != nil {
			return err
		}

		response := struct {
			Status string `json:"status,omitempty"`
		}{}

		err = json.Unmarshal(body, &response)

		if err != nil {
			return errors.New("failed unmarshalling response: " + err.Error())
		}

		if response.Status == "completed" {
			fmt.Println()
			return nil
		} else if response.Status == "pending" || response.Status == "running" {
			fmt.Print(".")
			time.Sleep(10 * time.Second)
		} else {
			fmt.Println()
			return errors.New("Report status is not correct. Status=" + response.Status)
		}
	}

	return nil
}

func triggerNewReportGeneration(xrayServiceMgr *xray.XrayServicesManager, serverConf *config.ServerDetails, pluginConfig *checkConfiguration) (int, error) {
	log.Info("Creating a vulnerability report...")
	url := clientutils.AddTrailingSlashIfNeeded(serverConf.XrayUrl) + "api/v1/reports/vulnerabilities"
	httpClientsDetails := httputils.HttpClientDetails{
		User:     serverConf.GetUser(),
		Password: serverConf.GetPassword(),
	}

	type repository struct {
		Name string `json:"name"`
	}

	type resources struct {
		Repositories []repository `json:"repositories"`
	}

	type filters struct {
		Cve string `json:"cve,omitempty"`
	}

	uuidStr, err := uuid.GenerateUUID()
	if err != nil {
		return 0, err
	}

	requestBody := struct {
		Name      string    `json:"name,omitempty"`
		Resources resources `json:"resources,omitempty"`
		Filters   filters   `json:"filters,omitempty"`
	}{
		Name: pluginConfig.issueId + "_" + uuidStr,
		Filters: filters{
			Cve: pluginConfig.issueId,
		},
	}

	if pluginConfig.repositories != nil && len(pluginConfig.repositories) > 0 {
		requestBody.Resources = resources{
			Repositories: make([]repository, 0),
		}
		for _, repoName := range pluginConfig.repositories {
			requestBody.Resources.Repositories = append(requestBody.Resources.Repositories, repository{Name: repoName})
		}
	}

	content, err := json.Marshal(requestBody)
	if err != nil {
		return 0, err
	}

	artUtils.SetContentType("application/json", &httpClientsDetails.Headers)
	resp, body, err := xrayServiceMgr.Client().SendPost(url, content, &httpClientsDetails)

	if err = errorutils.CheckResponseStatus(resp, http.StatusOK); err != nil {
		return 0, err
	}

	response := struct {
		ReportId int `json:"report_id"`
	}{}

	err = json.Unmarshal(body, &response)

	if err != nil {
		return 0, errors.New("failed unmarshalling response: " + err.Error())
	}

	if response.ReportId == 0 {
		return 0, errors.New("did not get report_id in response from Xray")
	}

	log.Info("Report created. Name=" + requestBody.Name + ", ID=" + strconv.Itoa(response.ReportId))

	return response.ReportId, nil
}

func printImpactedComponents(comps []impactedComponent) {
	log.Warn("*** Affected components in the system ***")
	for _, comp := range comps {
		log.Warn("		" + comp.PackageType + "://" + comp.Name + ":" + comp.Version)
	}
	log.Warn("*****************************************")
}

func getImpactedComponents(xrayServiceMgr *xray.XrayServicesManager, serverConf *config.ServerDetails, issueId string) ([]impactedComponent, error) {
	log.Info("Checking impacted components...")
	url := clientutils.AddTrailingSlashIfNeeded(serverConf.XrayUrl) + "api/v1/component/searchByCves"
	httpClientsDetails := httputils.HttpClientDetails{
		User:     serverConf.GetUser(),
		Password: serverConf.GetPassword(),
	}

	requestBody := struct {
		CVEs []string `json:"cves"`
	}{
		CVEs: []string{issueId},
	}
	content, err := json.Marshal(requestBody)
	if err != nil {
		return nil, err
	}

	artUtils.SetContentType("application/json", &httpClientsDetails.Headers)
	resp, body, err := xrayServiceMgr.Client().SendPost(url, content, &httpClientsDetails)

	if err = errorutils.CheckResponseStatus(resp, http.StatusOK); err != nil {
		return nil, err
	}

	type impactedComponentBlock struct {
		Components []impactedComponent `json:"components"`
	}

	impactedComponentResponse := make([]impactedComponentBlock, 0)

	err = json.Unmarshal(body, &impactedComponentResponse)

	if err != nil {
		return nil, errors.New("failed unmarshalling impacted components response: " + err.Error())
	}

	if len(impactedComponentResponse) != 1 {
		return nil, errors.New("impacted components size incorrect")
	}

	return impactedComponentResponse[0].Components, nil
}

func printIssueDetails(cve string, summary string) {
	log.Info("CVE: " + cve + ",Summary: " + summary)
}

func getIssueDetails(xrayServiceMgr *xray.XrayServicesManager, serverConf *config.ServerDetails, issueId string) (string, string, error) {
	log.Info("Getting issue details...")
	getIssueDetailsURL := clientutils.AddTrailingSlashIfNeeded(serverConf.XrayUrl) + "api/v1/events/" + issueId
	httpClientsDetails := httputils.HttpClientDetails{
		User:     serverConf.GetUser(),
		Password: serverConf.GetPassword(),
	}

	resp, body, _, err := xrayServiceMgr.Client().SendGet(getIssueDetailsURL, true, &httpClientsDetails)
	if err != nil {
		return "", "", err
	}

	if resp.StatusCode == 404 {
		//goland:noinspection GoErrorStringFormat
		return "", "", errors.New("Issue was not found in Xray DB. " +
			"Make sure that the db-sync run and the issue ID is correct")
	}
	if err = errorutils.CheckResponseStatus(resp, http.StatusOK); err != nil {
		return "", "", err
	}

	issueDetailsResponse :=
		struct {
			Summary string `json:"summary"`
			Cve     string `json:"source_id"`
		}{}

	err = json.Unmarshal(body, &issueDetailsResponse)

	if err != nil {
		return "", "", errors.New("failed unmarshalling issue details response: " + err.Error())
	}

	return issueDetailsResponse.Cve, issueDetailsResponse.Summary, nil
}

func checkConnection(xrayServiceMgr *xray.XrayServicesManager) error {
	log.Info("Checking connection to xray server...")
	version, err := xrayServiceMgr.GetVersion()

	if err != nil {
		return err
	}

	if version == "" {
		return errors.New("empty version returned by Xray")
	}
	return nil
}
