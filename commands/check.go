package commands

import (
	"encoding/json"
	"errors"
	"github.com/jfrog/jfrog-cli-core/v2/plugins/components"
	"github.com/jfrog/jfrog-client-go/utils/log"
	"github.com/rdar-lab/cve-impact-check/service"
	"os"
	"strconv"
	"strings"
)

func GetCheckCommand() components.Command {
	return components.Command{
		Name:        "check",
		Description: "Checks if a CVE/XRAY ID has impact on a system",
		Aliases:     []string{"c"},
		Arguments:   getCheckArguments(),
		Flags:       getCheckFlags(),
		EnvVars:     getCheckEnvVar(),
		Action: func(ctx *components.Context) error {
			return checkCmd(ctx)
		},
	}
}

func getCheckArguments() []components.Argument {
	return []components.Argument{
		{
			Name:        "issue_id",
			Description: "The CVE or XRAY ID of the issue",
		},
	}
}

func getCheckFlags() []components.Flag {
	return []components.Flag{
		components.BoolFlag{
			Name:         "export-impacted-artifacts",
			Description:  "Generate a report of the impacted artifacts",
			DefaultValue: false,
		},
		components.StringFlag{
			Name:         "repositories",
			Description:  "Comma separated list of repositories to check in",
			DefaultValue: "",
		},
		components.StringFlag{
			Name:         "output",
			Description:  "The destination output file",
			DefaultValue: "out.json",
		},
		components.StringFlag{
			Name:         "server-id",
			Description:  "The Server to connect to",
			DefaultValue: "",
		},
	}
}

func getCheckEnvVar() []components.EnvVar {
	return []components.EnvVar{}
}

type checkConfiguration struct {
	issueId         string
	exportArtifacts bool
	repositories    []string
	outputFile      string
	serverId        string
}

func checkCmd(ctx *components.Context) error {
	if len(ctx.Arguments) != 1 {
		return errors.New("Wrong number of arguments. Expected: 1, " + "Received: " + strconv.Itoa(len(ctx.Arguments)))
	}
	var conf = new(checkConfiguration)
	conf.issueId = ctx.Arguments[0]
	conf.exportArtifacts = ctx.GetBoolFlagValue("export-impacted-artifacts")

	reposStr := ctx.GetStringFlagValue("repositories")
	if reposStr == "" {
		conf.repositories = nil
	} else {
		conf.repositories = strings.Split(reposStr, ",")
	}

	conf.outputFile = ctx.GetStringFlagValue("output")
	conf.serverId = ctx.GetStringFlagValue("server-id")

	return doCheck(conf, &service.LiveServerConnector{})
}

func validateConf(pluginConfig *checkConfiguration) error {
	if pluginConfig.exportArtifacts && pluginConfig.repositories == nil {
		//goland:noinspection GoErrorStringFormat
		return errors.New("When selecting to export the impacted artifacts, the repository selection is required")
	}

	if !strings.HasPrefix(pluginConfig.issueId, "XRAY-") &&
		!strings.HasPrefix(pluginConfig.issueId, "CVE-") {
		return errors.New("incorrect ID format. Please use only XRAY-XXX or CVE-XXX formats")
	}

	return nil
}

func doCheck(pluginConfig *checkConfiguration, connector service.ServerConnector) error {
	err := validateConf(pluginConfig)

	if err != nil {
		return err
	}

	err = connector.Connect(pluginConfig.serverId)

	if err != nil {
		return err
	}

	if strings.HasPrefix(pluginConfig.issueId, "XRAY-") {
		cve, issueDetails, err := connector.GetIssueDetails(pluginConfig.issueId)
		if err != nil {
			return err
		}
		printIssueDetails(cve, issueDetails)
		pluginConfig.issueId = cve
	}

	impactedComponents, err := connector.GetImpactedComponents(pluginConfig.issueId)
	if err != nil {
		return err
	}

	if len(impactedComponents) == 0 {
		log.Info("No impacted components found in the system")
		return nil
	}

	printImpactedComponents(impactedComponents)

	if pluginConfig.exportArtifacts {
		err = generateImpactedArtifactsReport(pluginConfig, connector)
		if err != nil {
			return err
		}
	}

	return nil
}

func generateImpactedArtifactsReport(pluginConfig *checkConfiguration, connector service.ServerConnector) error {
	reportId, err := connector.TriggerNewReportGeneration(pluginConfig.issueId, pluginConfig.repositories)

	if err != nil {
		return err
	}

	defer func() {
		err = connector.DeleteReport(reportId)
		if err != nil {
			log.Error("Was unable to remove report due to: " + err.Error())
			log.Error("You will need to manually remove the report from Xray UI")
		}
	}()

	err = connector.WaitForReportGeneration(reportId)

	if err != nil {
		return err
	}

	data, err := connector.GetReportData(reportId)
	if err != nil {
		return err
	}
	err = saveReportData(pluginConfig, data)
	if err != nil {
		return err
	}

	return nil
}

func saveReportData(pluginConfig *checkConfiguration, rows []service.ImpactedArtifact) error {
	if len(rows) == 0 {
		log.Info("No impacted artifacts detected")
	} else {
		content, err := json.Marshal(rows)
		if err != nil {
			return err
		}

		outputFile, err := os.Create(pluginConfig.outputFile)
		defer func() {
			_ = outputFile.Close()
		}()
		_, err = outputFile.Write(content)
		if err != nil {
			return err
		}
	}
	return nil
}

func printImpactedComponents(comps []service.ImpactedComponent) {
	log.Warn("*** Affected components in the system ***")
	for _, comp := range comps {
		log.Warn("		" + comp.PackageType + "://" + comp.Name + ":" + comp.Version)
	}
	log.Warn("*****************************************")
}

func printIssueDetails(cve string, summary string) {
	log.Info("CVE: " + cve + ",Summary: " + summary)
}
