package service

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/hashicorp/go-uuid"
	"github.com/jfrog/jfrog-cli-core/v2/utils/config"
	"github.com/jfrog/jfrog-cli-core/v2/xray/commands"
	artUtils "github.com/jfrog/jfrog-client-go/artifactory/services/utils"
	clientutils "github.com/jfrog/jfrog-client-go/utils"
	"github.com/jfrog/jfrog-client-go/utils/errorutils"
	"github.com/jfrog/jfrog-client-go/utils/io/httputils"
	"github.com/jfrog/jfrog-client-go/utils/log"
	"github.com/jfrog/jfrog-client-go/xray"
	"net/http"
	"strconv"
	"time"
)

type ImpactedComponent struct {
	Name        string `json:"name"`
	PackageType string `json:"package_type"`
	Version     string `json:"version"`
}

type ImpactedArtifact struct {
	Summary   string `json:"summary"`
	Component string `json:"vulnerable_component"`
	Artifact  string `json:"impacted_artifact"`
	Path      string `json:"path"`
}

type ServerConnector interface {
	Connect(serverId string) error
	GetIssueDetails(issueId string) (string, string, error)
	GetImpactedComponents(issueId string) ([]ImpactedComponent, error)
	DeleteReport(reportId int) error
	GetReportData(reportId int) ([]ImpactedArtifact, error)
	WaitForReportGeneration(reportId int) error
	TriggerNewReportGeneration(issueId string, repositories []string) (int, error)
}

type LiveServerConnector struct {
	serverConf     *config.ServerDetails
	xrayServiceMgr *xray.XrayServicesManager
}

func (connector *LiveServerConnector) checkConnection() error {
	log.Info("Checking connection to xray server...")
	version, err := connector.xrayServiceMgr.GetVersion()

	if err != nil {
		return err
	}

	if version == "" {
		return errors.New("empty version returned by Xray")
	}
	return nil
}

func (connector *LiveServerConnector) Connect(serverId string) error {
	serverConf, err := config.GetSpecificConfig(serverId, true, false)

	if err != nil {
		return err
	}

	if serverConf.XrayUrl == "" {
		return errors.New("xray service is not configured")
	}

	connector.serverConf = serverConf

	xrayServiceMgr, err := commands.CreateXrayServiceManager(serverConf)
	if err != nil {
		return err
	}

	connector.xrayServiceMgr = xrayServiceMgr

	err = connector.checkConnection()
	if err != nil {
		return err
	}

	return nil
}

func (connector *LiveServerConnector) GetIssueDetails(issueId string) (string, string, error) {
	log.Info("Getting issue details...")
	getIssueDetailsURL := clientutils.AddTrailingSlashIfNeeded(connector.serverConf.XrayUrl) + "api/v1/events/" + issueId
	httpClientsDetails := httputils.HttpClientDetails{
		User:     connector.serverConf.GetUser(),
		Password: connector.serverConf.GetPassword(),
	}

	resp, body, _, err := connector.xrayServiceMgr.Client().SendGet(getIssueDetailsURL, true, &httpClientsDetails)
	if err != nil {
		return "", "", err
	}

	if resp.StatusCode == 404 {
		//goland:noinspection GoErrorStringFormat
		return "", "", errors.New("Issue was not found in Xray DB. " +
			"Make sure that the db-sync run and the issue ID is correct")
	}
	if err = errorutils.CheckResponseStatus(resp, http.StatusOK); err != nil {
		return "", "", err
	}

	issueDetailsResponse :=
		struct {
			Summary string `json:"summary"`
			Cve     string `json:"source_id"`
		}{}

	err = json.Unmarshal(body, &issueDetailsResponse)

	if err != nil {
		return "", "", errors.New("failed unmarshalling issue details response: " + err.Error())
	}

	return issueDetailsResponse.Cve, issueDetailsResponse.Summary, nil
}

func (connector *LiveServerConnector) GetImpactedComponents(issueId string) ([]ImpactedComponent, error) {
	log.Info("Checking impacted components...")
	url := clientutils.AddTrailingSlashIfNeeded(connector.serverConf.XrayUrl) + "api/v1/component/searchByCves"
	httpClientsDetails := httputils.HttpClientDetails{
		User:     connector.serverConf.GetUser(),
		Password: connector.serverConf.GetPassword(),
	}

	requestBody := struct {
		CVEs []string `json:"cves"`
	}{
		CVEs: []string{issueId},
	}
	content, err := json.Marshal(requestBody)
	if err != nil {
		return nil, err
	}

	artUtils.SetContentType("application/json", &httpClientsDetails.Headers)
	resp, body, err := connector.xrayServiceMgr.Client().SendPost(url, content, &httpClientsDetails)

	if err = errorutils.CheckResponseStatus(resp, http.StatusOK); err != nil {
		return nil, err
	}

	type impactedComponentBlock struct {
		Components []ImpactedComponent `json:"components"`
	}

	impactedComponentResponse := make([]impactedComponentBlock, 0)

	err = json.Unmarshal(body, &impactedComponentResponse)

	if err != nil {
		return nil, errors.New("failed unmarshalling impacted components response: " + err.Error())
	}

	if len(impactedComponentResponse) != 1 {
		return nil, errors.New("impacted components size incorrect")
	}

	return impactedComponentResponse[0].Components, nil
}

func (connector *LiveServerConnector) DeleteReport(reportId int) error {
	log.Info("Deleting report...")
	url := clientutils.AddTrailingSlashIfNeeded(connector.serverConf.XrayUrl) + "api/v1/reports/" + strconv.Itoa(reportId)
	httpClientsDetails := httputils.HttpClientDetails{
		User:     connector.serverConf.GetUser(),
		Password: connector.serverConf.GetPassword(),
	}

	resp, _, err := connector.xrayServiceMgr.Client().SendDelete(url, nil, &httpClientsDetails)

	if err = errorutils.CheckResponseStatus(resp, http.StatusOK); err != nil {
		return err
	}

	return nil
}

func (connector *LiveServerConnector) GetReportData(reportId int) ([]ImpactedArtifact, error) {
	log.Info("Downloading report data...")
	url := clientutils.AddTrailingSlashIfNeeded(connector.serverConf.XrayUrl) + "api/v1/reports/vulnerabilities/" + strconv.Itoa(reportId)

	url = url + "?direction=asc&page_num=1&num_of_rows=10000&order_by=path"

	httpClientsDetails := httputils.HttpClientDetails{
		User:     connector.serverConf.GetUser(),
		Password: connector.serverConf.GetPassword(),
	}

	resp, body, err := connector.xrayServiceMgr.Client().SendPost(url, nil, &httpClientsDetails)
	if err != nil {
		return nil, err
	}

	if err = errorutils.CheckResponseStatus(resp, http.StatusOK); err != nil {
		return nil, err
	}

	response := struct {
		Rows []ImpactedArtifact `json:"rows,omitempty"`
	}{}

	err = json.Unmarshal(body, &response)

	if err != nil {
		return nil, errors.New("failed unmarshalling response: " + err.Error())
	}

	return response.Rows, nil
}

func (connector *LiveServerConnector) WaitForReportGeneration(reportId int) error {
	log.Info("Waiting for report to finish execution...")
	url := clientutils.AddTrailingSlashIfNeeded(connector.serverConf.XrayUrl) + "api/v1/reports/" + strconv.Itoa(reportId)
	httpClientsDetails := httputils.HttpClientDetails{
		User:     connector.serverConf.GetUser(),
		Password: connector.serverConf.GetPassword(),
	}

	for true {
		resp, body, _, err := connector.xrayServiceMgr.Client().SendGet(url, true, &httpClientsDetails)
		if err != nil {
			return err
		}

		if err = errorutils.CheckResponseStatus(resp, http.StatusOK); err != nil {
			return err
		}

		response := struct {
			Status string `json:"status,omitempty"`
		}{}

		err = json.Unmarshal(body, &response)

		if err != nil {
			return errors.New("failed unmarshalling response: " + err.Error())
		}

		if response.Status == "completed" {
			fmt.Println()
			return nil
		} else if response.Status == "pending" || response.Status == "running" {
			fmt.Print(".")
			time.Sleep(10 * time.Second)
		} else {
			fmt.Println()
			return errors.New("Report status is not correct. Status=" + response.Status)
		}
	}

	return nil
}

func (connector *LiveServerConnector) TriggerNewReportGeneration(issueId string, repositories []string) (int, error) {
	log.Info("Creating a vulnerability report...")
	url := clientutils.AddTrailingSlashIfNeeded(connector.serverConf.XrayUrl) + "api/v1/reports/vulnerabilities"
	httpClientsDetails := httputils.HttpClientDetails{
		User:     connector.serverConf.GetUser(),
		Password: connector.serverConf.GetPassword(),
	}

	type repository struct {
		Name string `json:"name"`
	}

	type resources struct {
		Repositories []repository `json:"repositories"`
	}

	type filters struct {
		Cve string `json:"cve,omitempty"`
	}

	uuidStr, err := uuid.GenerateUUID()
	if err != nil {
		return 0, err
	}

	requestBody := struct {
		Name      string    `json:"name,omitempty"`
		Resources resources `json:"resources,omitempty"`
		Filters   filters   `json:"filters,omitempty"`
	}{
		Name: issueId + "_" + uuidStr,
		Filters: filters{
			Cve: issueId,
		},
	}

	if repositories != nil && len(repositories) > 0 {
		requestBody.Resources = resources{
			Repositories: make([]repository, 0),
		}
		for _, repoName := range repositories {
			requestBody.Resources.Repositories = append(requestBody.Resources.Repositories, repository{Name: repoName})
		}
	}

	content, err := json.Marshal(requestBody)
	if err != nil {
		return 0, err
	}

	artUtils.SetContentType("application/json", &httpClientsDetails.Headers)
	resp, body, err := connector.xrayServiceMgr.Client().SendPost(url, content, &httpClientsDetails)

	if err = errorutils.CheckResponseStatus(resp, http.StatusOK); err != nil {
		return 0, err
	}

	response := struct {
		ReportId int `json:"report_id"`
	}{}

	err = json.Unmarshal(body, &response)

	if err != nil {
		return 0, errors.New("failed unmarshalling response: " + err.Error())
	}

	if response.ReportId == 0 {
		return 0, errors.New("did not get report_id in response from Xray")
	}

	log.Info("Report created. Name=" + requestBody.Name + ", ID=" + strconv.Itoa(response.ReportId))

	return response.ReportId, nil
}
